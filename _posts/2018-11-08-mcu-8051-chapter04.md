---
layout: post
title: 第四节：累计定时中断次数使LED灯闪烁。
tags: mcu
---

开场白：
上一节提到在累计主循环次数来实现计时，随着主函数里任务量的增加，为了保证延时时间的准确性，要不断修正设定上限阀值const_time_level 。我们该怎么解决这个问题呢？本节教大家利用累计定时中断次数的方法来解决这个问题。这一节要教会大家四个知识点：
第一点：利用累计定时中断次数的方法实现时间延时
第二点：展现鸿哥最完整的实战程序框架。在主函数循环里用switch语句实现状态机的切换，在定时中断里累计中断次数，这两个的结合就是我写代码最本质的框架思想。 
第三点：提醒大家C语言中的int ,long变量是由几个字节构成的数据，凡是在main函数和中断函数里有可能同时改变的变量，这个变量应该在主函数中被更改之前，先关闭相应的中断，更改完了此变量，再打开中断，否则会留下不宜察觉的漏洞。当然在大部分的项目中可以不用这么操作，但是在一些要求非常高的项目中，有一些核心变量必须这么做。
第四点：定时中断的初始值该怎么设置。不用严格按公式来计算时间，一般取个经验值是最大初始值减去1000就可以了。
具体内容，请看源代码讲解。

（1）硬件平台：基于朱兆祺51单片机学习板。

（2）实现功能：让一个LED闪烁。

（3）源代码讲解如下：

```
#include "REG52.H"

#define const_time_level 200  

void initial_myself();    
void initial_peripheral();
void delay_long(unsigned int uiDelaylong);
void led_flicker();
void T0_time();  //定时中断函数

sbit led_dr=P3^5;  

unsigned char ucLedStep=0; //步骤变量
unsigned int  uiTimeCnt=0; //统计定时中断次数的延时计数器


void main() 
  {
   initial_myself();  
   delay_long(100);   
   initial_peripheral(); 
   while(1)   
   {
      led_flicker();   
   }

}

void led_flicker() ////第三区 LED闪烁应用程序
{
  
  switch(ucLedStep)
  {
     case 0:
/* 注释一：
* uiTimeCnt累加定时中断的次数，每一次定时中断它都会在中断函数里自加一。
* 只有当它的次数大于或等于设定上限const_time_level时，
* 才会去改变LED灯的状态，否则CPU退出led_flicker()任务，继续快速扫描其他的任务，
* 这样的程序结构就可以达到多任务并行处理的目的。这就是鸿哥在所有开发项目中的核心框架。
*/
                  if(uiTimeCnt>=const_time_level) //时间到
                  {

/* 注释二：
* ET0=0;uiTimeCnt=0;ET0=1;----在清零uiTimeCnt之前，为什么要先禁止定时中断？
* 因为uiTimeCnt是unsigned int类型，本质上是由两个字节组成。
* 在C语言中uiTimeCnt=0看似一条指令，实际上经过编译之后它不只一条汇编指令。
* 由于定时中断函数里也对这个变量进行累加操作，如果不禁止定时中断，
* 那么uiTimeCnt这个变量在main()函数中还没被完全清零的时候，如果这个时候
* 突然来一个定时中断，并且在中断里又更改了此变量，这种情况在某些要求高的
* 项目上会是一个不容易察觉的漏洞，为项目带来隐患。当然，大部分的普通项目，
* 都可以不用那么严格，可以不用禁止定时中断。在这里只是提醒各位初学者有这种情况。
*/
             ET0=0;  //禁止定时中断
                     uiTimeCnt=0; //时间计数器清零
             ET0=1; //开启定时中断
             led_dr=1;    //让LED亮
                         ucLedStep=1; //切换到下一个步骤
                  }
              break;
     case 1:
                  if(uiTimeCnt>=const_time_level) //时间到
                  {
             ET0=0;  //禁止定时中断
                     uiTimeCnt=0; //时间计数器清零
             ET0=1;   //开启定时中断
             led_dr=0;    //让LED灭
                         ucLedStep=0; //返回到上一个步骤
                  }
              break;
  
  }

}


/* 注释三：
* C51的中断函数格式如下：
* void 函数名() interrupt 中断号
* {
*    中断程序内容
* }
* 函数名可以随便取，只要不是编译器已经征用的关键字。
* 这里最关键的是中断号，不同的中断号代表不同类型的中断。
* 定时中断的中断号是 1.至于其它中断的中断号，大家可以查找
* 相关书籍和资料。大家进入中断时，必须先清除中断标志，并且
* 关闭中断，然后再写代码，最后出来时，记得重装初始值，并且
* 打开中断。
*/
void T0_time() interrupt 1
{
  TF0=0;  //清除中断标志
  TR0=0; //关中断

  if(uiTimeCnt<0xffff)  //设定这个条件，防止uiTimeCnt超范围。
  {
      uiTimeCnt++;  //累加定时中断的次数，
  }

TH0=0xf8;   //重装初始值(65535-2000)=63535=0xf82f
TL0=0x2f;
TR0=1;  //开中断
}


void delay_long(unsigned int uiDelayLong)
{
   unsigned int i;
   unsigned int j;
   for(i=0;i<uiDelayLong;i++)
   {
      for(j=0;j<500;j++)  //内嵌循环的空指令数量
          {
             ; //一个分号相当于执行一条空语句
          }
   }
}


void initial_myself()  //第一区 初始化单片机
{

/* 注释四：
* 单片机有几个定时器，每个定时器又有几种工作方式，
* 那么多种变化，我们记不了那么多，怎么办？
* 大家记住鸿哥的话,无论一个单片机有多少内置资源，
* 我们做系统框架的，只需要一个定时器，一种工作方式。
* 开定时器越多这个系统越不好。需要哪种定时工作方式呢？
* 就需要响应定时中断后重装一下初始值继续跑那种。
* 在51单片机中就是工作方式1。其它的工作方式很少项目能用到。
*/
  TMOD=0x01;  //设置定时器0为工作方式1


  /* 注释五：
* 装定时器的初始值，就像一个水桶里装的水。如果这个桶是空桶，那么想
* 把这个桶灌满水的时间就很长，如果是里面已经装了大半的水，那么想
* 把这个桶灌满水的时间就相对比较短。也就是定时器初始值越小，产生一次
* 定时中断的时间就越长。如果初始值太小了，每次产生定时中断
* 的时间分辨率太粗，如果初始值太大了，虽然每次产生定时中断的时间分辨率很细，
* 但是太频繁的产生中断，不但会影响主函数main()的执行效率，而且累记中断次数
* 的时间误差也会很大。凭鸿哥多年的江湖经验，
* 我觉得最大初始值减去2000是比较好的经验值。当然，大一点小一点没关系。不要走
* 两个极端就行。
*/
TH0=0xf8;   //重装初始值(65535-2000)=63535=0xf82f
TL0=0x2f;

  led_dr=0;  //LED灭
}
void initial_peripheral() //第二区 初始化外围
{
  EA=1;     //开总中断
  ET0=1;    //允许定时中断
  TR0=1;    //启动定时中断
}

```

总结陈词：
本节程序麻雀虽小五脏俱全。在本节中已经展示了我最完整的实战程序框架。
本节程序只有一个LED灯闪烁的单任务，如果要多增加一个任务来并行处理，该怎么办？
欲知详情，请听下回分解-----蜂鸣器的驱动程序。